<!DOCTYPE html>
<html>
    <head>
        <title>Leo | Operating System</title>
        <link rel="stylesheet" href="oscss.css">    
    </head>
    <body>
        <h1 id="top">Operating System</h1>
        <h3> Table of contents</h3>
        <a id="gh" href="../index.html" style="position: fixed; right: 20px; top: 20px;">Go Home</a>
        <h4><a href="#Thread">Thread</a></h4>
        <h4><a href="#Concurrent Program Execution">Concurrent Program Execution</a></h4>
        <h4><a href="#Timesharing and Content Switches">Timesharing and Content Swiches</a></h4>
        <h4><a href="#Thread States">Thread States</a></h4>
        <h4><a href="#Interrupt">Interrupt</a></h4>
        <h4><a href="#preemptive scheduling">Preemptive Scheduling</a></h4>
        <h4><a href="#synchronization">Synchronization</a></h4>
        <h4><a href="#CS">Critical Section</a></h4>
        <h4><a href="#rc">Race condition</a></h4>
        <h4><a href="#lock">Lock</a></h4>
        <h2 id="Thread">Thread</h2>
        <ul>
            <li><strong>What is a thread?</strong>
                <ul>
                    <li>Thread is a sequence of instructions.</li>
                    <li>A normal sequential program consists of a single thread of execution</li>
                    <li>Threads provide a way for programmers to express concurrency
                        (i.e. multiple programs or sequences of instructions running, or 
                        appearing to run at the same time) in a program</li>
                    <li>There are multiple threads of execution
                        <ul>
                            <li>Threads may perform the same task.</li>
                            <li>Threads may perform different tasks.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>Properties of Thread:</strong>
                <ul>
                    <li>Resource Utilization: blocked/waiting threads give up resource</li>
                    <li>Parallelism: multiple threads exectuing simultaneously</li>
                    <li>Responsiveness: dedicate threads to</li>
                    <li>Priority: higher priority, more CPU time; lower priority, less CPU time</li>
                    <li>Modularization: organization of execution tasks</li>
                </ul>
            </li>
            <li><strong>Important Notes for Thread:</strong>
                <ul>
                    <li>A thread can create new threads using thread_fork</li>
                    <li>All threads share the program global variables and heap, but they have
                        private stack
                    </li>
                    <li>Operating system control which thread to run, orignal thread and the new 
                        thread runs concurrenctly.
                    </li>
                    <li>Once the threads start running, you cannot predict the behavior since you have 
                        no control.
                    </li>
                </ul>
            </li>
        </ul>
        <h2 id="Concurrent Program Execution">Concurrent Program Execution</h2>
        <ul>
            <li>One program has at least one thread and all threads share that program address space.</li>
            <li>Operating system job to prevent stacks overlapping each other --> but also make sure
                to get the maximum stack
            </li>
            <li><strong>multithread program gives:</strong>
                 <ul>
                     <li>the illusion that be able to runs multi-things at the same time</li>
                     <li>better organization of the program</li>
                     <li>better performance of the program</li>
                 </ul>
                </li>
            <li><strong>Implementation Concurrent Thread</strong>
                <ul>
                    <li>Hardware support: P(processors)C(cores)M(multithreading per core)
                        PCM threads can execute simultaneously.
                    </li>
                    <li>Timesharing: Multiple threads take turns on the same hardware(share CPU); rapidly switching 
                        between threads so all make progress; they are all making progress, use CPU one by one
                    </li>
                    <li>Hardware support + Timesharing: PCM + timesharing</li>
                </ul>
            </li>
        </ul>
        <h2 id="Timesharing and Content Switches">Timesharing and Content Switches</h2>
            <ul>
                <li>When timesharing, the switch from one thread to another is called a content switch</li>
                <li><strong>During the timesharing:</strong>
                    <ul>
                        <li>decide which thread will run next (go to operating system schedulor)</li>
                        <li>save the states(register value) of the current thread</li>
                        <li>load the states(register value) of the nwe thread</li>
                        <strong><li style="color:red">make sure that the thread that running CPU again at the exact position
                            and exact states when it pick up
                        </li>
                        </strong>
                        <li>Thread context must be saved/restored carefully</li>
                        <li>switchframe_switch (callee): save all the callee-save registers</li>
                        <li>thread_switch (caller): save all the caller-save registers</li>
                    </ul>
                </li>
            <li><strong>What causes context switch?</strong>
                <ul>
                    <li>thread_yield: running thread voluntarily allows other threads to run; give up CPU voluntarily</li>
                </ul>
            </li>
            <li><strong>Four ways of context-switch:</strong>
                <ul>
                    <li>Go to Blocked state --> wait something</li>
                    <li>Preemption: involuntarily give up the CPU since the scheduling quantum count down expires --> interrupts --> context switch</li>
                    <li>Thread_yield: voluntarily called thread yield</li>
                    <li>Thread terminated;</li>
                </ul>
            </li>
            </ul>
        <h2 id="Thread States">Thread States</h2>
        <ul>
            <li><strong>Thread states (3 states)</strong>
                <ul>
                    <li>running: thread is executing on the CPU right now; if CPU only support one thread
                        at a time, then only one thread has that state.
                    </li>
                    <li>ready: the thread is not waiting for anything except CPU; waiting to run instructions</li>
                    <li>blocked: any threads that is waiting for something that can continue. waiting to receive the "order"
                        to execute 
                    </li>
                    <li>transection:
                        <ul>
                            <li>ready to running: called by contextswitch</li>
                            <li>running to ready: called by yield</li>
                            <li>running to blocked: need something so that need to go to blocked to wait for that</li>
                            <li>blocked to ready: when something becomes available, then some threads will take the blocked thread
                                and push to ready state
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>Thread Stack after Coluntary Context Switch</strong>
                <ul>
                    <li>program calls thread_yield first to yield CPU</li>
                    <li>thread_yield then calls thread_switch, to perform a context switch</li>
                    <li>thread_switch chooses a new thread, calls switchframe_switch to perfrom low-level content switch</li>
                </ul>
            </li>
            <li><strong>Timesharing and Preemption:</strong>
                <ul>
                    <li>timesharing -- scheduling quantum (the upper bound on how long a thread can run before
                        must yield the CPU), it is involunteering stop.
                    </li>
                    <li>preemption forces a running thread to stop</li>
                    <li>Since CPU can only run one thread and that one is not aware that it needs to stop; the only way to stop a thread is through hardware -- using Interrupt!</li>
                </ul>
            </li>
        </ul>
        <h2 id="Interrupt">Interrupt</h2> <a href=""></a>
        <ul>
            <li>an interrupt is an event that occurs during the execution of a program</li>
            <li>interrupts are caused by system devices</li>
            <li>CPU know who causes the interrupt and OS handle the interrupts</li>
            <li>CPU has a trap table where stores some addresses of some codes.
                <ul>
                    <li>CPU --> receive interrupts --> stop executing user's program --> execute the code 
                        stored in address of the trap table (Interrupt handler (operating system code))
                    </li>
                </ul>
            </li>
            <li><strong>Interrupt handler</strong>
                <ol>
                    <li>create a trap frame; save every register in the system</li>
                    <li>called the actual handler --> perform device-specific processing</li>
                    <li>restores the saved thread context from the trap frame and resuems execution of the thread</li>
                </ol>
            </li>
            <li>Trap frame is always followed by the interrupt</li>
            <li>Interrupt handler stack frame followed by the trap frame</li>
            <li><strong>Difference between trap frame and switch functions</strong>
                <ul>
                    <li>trap frame saves all the registers comes before (the previous running program's registers)</li>
                    <li>thread_switch save all the registers between trap frame and itself (i.e. callee-save registers)</li>
                    <li>switchframe save all the registers (i.e. caller-save registers)</li>
                    <li>trap frame called by CPU not program(cannot be predict when to be called, so we need to save every register), 
                        while switch functions called by program!</li>
                </ul>
            </li>
        </ul>
        <h2 id="preemptive scheduling">Preemptive Scheduling</h2>
        <ul>
            <li>Preemptive Scheduling uses the schduling quantum</li>
            <li>Quantum cannot be too long --> not effective timesharing; cannot be too short --> spend more time on timesharing, not do so much work!</li>
            <li>Every time the new thread get a fresh quantum, so quantum does not carry over</li>
            <li>Every computer has clock --> run the count down --> when the count down is expire --> clock fire a interrupt --> causes CPU to execute the 
                interrupt handler so OS take control of the interrupts (i.e. execute content switch (yield -> thread_switch -> switchframe)
            <li><strong>Two passes to implement</strong>
                <ol>
                    <li>Every time there is a content switch, tell the clock to start a new count down --> really slow</li>
                    <li>Clock count down in a short period and repeat, when there is a time interrupt, go check (when the thread start running (record it))
                        whether it exceed its quantum, if yes, kick out, otherwise keep running.
                    </li>
                </ol>
            </li>
            </li>
        </ul>
        <h2 id="synchronization">Synchronization</h2>
        <ul>
            <li>
                All threads in a concurrent program <strong style="color:red">share access</strong> to the program's global variables and the heap (read & write).
            </li>
            <li>Any block of codes in a concurrent program where we have multiple threads reading and writing the shared variable(either global or heap) 
                is called <strong style="color: red">critical section</strong>
            </li>
        </ul>
        <h2 id="CS">Critical Section</h2>
            <ul>
                <li>The order of the instructions to be exectued in that section <strong style="color: red">matters</strong></li>
                <li>no control during preemption, no control over which thread run next --> OS have ability controlling</li>
                <li>Context switch happens expected to assembling, instead of C code.</li>
                <li>There are multiple programs running background, therefore, interrupts happens every time.</li>
            </ul>
        </ul>
        <h2 id="rc">Race Condition</h2>
        <ul>
            <li>when the program result depends on the order of execution.</li>
            <li>can cause: incorrect output, return error; memory error</li>
            <li>Race conditions occurs when multiple threads are reading and writing the same memory at the same time</li>
            <li>Source of race conditions:
                <ul>
                    <li>implementation</li>
                    <li></li>
                    <li></li>
                </ul>
            </li>
            <li>Identify race conditions
                <ul>
                    <li>inspect each variable; is it possible for multiple threads to read/write it at the same time?</li>
                    <li>constants and memoery that all threads only <strong style="color:red">read</strong>
                </ul>
            </li>
        </ul>
        <h2 id="lock">Enforcing Mutual Exclusion With Lock</h2>
        <ul>
            <li>acquire/release must ensure that only one thread at a time can hold the lock, even if both attempt to Acquire at the same time.</li>
            <li>If a thread cannot Acquire the lock immediately, it must wait until the lock is available.</li>
            <li>Must <strong style="color: red">ACQUIRE</strong> the lock before exeucting the shared variable.</li>
            <li>C code cannot stop the interrupts & context switch, we need hardware to help 
                <ul>
                    <li>provide a way to implement <strong style="color: red">atomic test-and-set</strong> (i.e. atomic means cannot be interrupted!) for synchoronization primitives like locks</li>
                </ul>
            </li>
        </ul>
        <a href="#top" style="position:fixed; right: 20px; top: 50px">Back To Top</a>
    </body>
</html>